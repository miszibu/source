---
title: Java_GC
date: 2018-03-29 14:44:32
tags: [Java]
---

## 综述

​	相比较C++需要在程序中自行处理内存的回收释放。Java在JVM虚拟机上增加了GC机制，用以在合适的时间通过垃圾回收，回收不需要的数据，从而减少内存占用，避免OOM(Out Of Memory)。掌握GC知识一方面可以帮助我们快速排查因JVM导致的线上问题，另一方面也可以帮助我们在Java应用发布之前合理地对JVM进行调优，提高应用的执行效率、可靠性和健壮性。

## 1.Java堆内存结构

Java堆内存分三大部分:新生代，老年代和永久代。

新生代又进一步划分为Eden,S0,S1(Survivor)三个区。结构如下：

```java
+---------------------------+-------------------------------+-------------------+
|                     |  |  |                               |                   |
|         Eden        |S0|S1|       Old generation          |      Perm         |
|                     |  |  |                               |                   |
+---------------------------+-------------------------------+-------------------+
|<----Young Gen Space------>|
```

<!-- more -->

程序中新new出来的对象，会被送到Eden区域，若存活时间就会被送入Survivior区域，若存活时间更久，就会被分配到老年代。持久代则存放Class类元数据，方法描述等,一般为4M。

> 1. S0和S1是两个大小相等的区域，分配内存空间只会在其中某一个进行，另外一个空间是用来辅助进行新生代进行垃圾回收的，因为新生代的垃圾回收策略基于复制算法，每次回收Eden+S0或者Eden+S!,若回收Eden+S0,则将这两个区域中的存活对象存入S1区域，将其死亡对象回收，反之亦然，如此循环利用。 
> 2. 有些文章并不将永久代纳入Java堆内存。其实永久代就是我们所说的方法区，而方法区经常被称为Non-Heap。仅仅在HotSpot虚拟机的实现中才将GC分代收集扩展至方法区，或者说使用永久代来实现方法区，对于其他的虚拟机是不存在永久代这个概念的。 
> 3. 并非所有的对象创建都会在Eden区中分配内存空间。对于Serial和ParNew垃圾收集器,通过指定-XX:PretenureSizeThreshold={size}来设置超过这个阈值大小的对象直接进入老年代。



## 2. 分代回收算法

垃圾回收主要针对Java堆内存中的新生代和老年代，不同生代的垃圾回收采用不同的回收算法。

针对新生代，主要采用**复制算法**，而针对老年代，通常采用**标记-清除算法**或者**标记-整理算法**来进行回收。

### 2.1 复制算法

复制算法的思想是将内存分成大小相等的两块区域，每次使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块区域上，然后对该块进行内存回收。示例图如下所示：

![复制算法图解](../img/show-copy-algorithm.png)





这个算法实现简单，并且也相对高效，但是代价就是需要将牺牲一半的内存空间用于进行复制。有研究表明，新生代中的对象98%存活期很短，所以并不需要以1:1的比例来划分整个新生代，通常的做法是将新生代内存空间划分成一块较大的Eden区和两块较小的Survivor区，两块Survivor区域的大小保持一致。每次使用Eden和其中一块Survivor区，当回收的时候，将还存活的对象复制到另外一块Survivor空间上，最后清除Eden区和一开始使用的Survivor区。假如用于复制的Survivor区放不下存活的对象，那么会将对象存到老年代。

> HotSpot虚拟机默认Eden和Survivor的大小比例是8:1:1，也就是说新生代中牺牲掉10%的空间而不是一半的空间。

### 2.2 标记-清除算法

标记-清除(Mark-Sweep)算法分为两个阶段：

- **标记**
- **清除**

在**标记阶段**将标记出需要回收的对象空间，然后在下一个阶段**清除阶段**里面，将这些标记出来的对象空间回收掉。这种算法有两个主要问题：一个是标记和清除的效率不高，另一个问题是在清理之后会产生大量不连续的内存碎片，这样会导致在分配大对象时候无法找到足够的连续内存而触发另一次垃圾收集动作。标记-清除算法示例图如下所示：

![标记-清除算法图解](../img/show-mark-sweep-algorithm.png)

### 2.3 标记-整理算法

标记-整理(Mark-Compact)算法有效预防了标记-清除算法中可能产生过多内存碎片的问题。在标记需要回收的对象以后，它会将所有存活的对象空间挪到一起，然后再执行清理。示例图如下所示：

![标记-整理算法图解](../img/show-mark-compact-algorithm.png)

> 标记-整理通常会在标记-清除算法里面作为备选方案，为了防止标记-清除后产生大量内存碎片而无法为大对象分配足够内存的情况，如后面所讲的Serial Old收集器(基于标记-整理算法实现)将会作为CMS收集器(基于标记-清除算法实现)的备选方案。

## 3. 垃圾收集器

因为新生代和老年代采用回收算法的不同，垃圾收集器相应地也分为新生代收集器和老年代收集器。其中新生代收集器主要有Serial收集器、ParNew收集器和Parallel Scavenge收集器。老年代收集器主要有Serial Old收集器、Parallel Old收集器和CMS收集器。

### 3.1 新生代收集器

#### 3.1.1 Serial收集器

Serial收集器作用于新生代，是一个单线程收集器，基于复制算法实现。在进行垃圾回收的时候仅使用单条线程并且在回收的过程中会挂起所有的用户线程(Stop The World)。Serial收集器是JVM client模式下默认的新生代收集器。

![Serial收集器图解](http://7xtamf.com1.z0.glb.clouddn.com/image%2Fblog%2Fjava-gc-introduction%2Fshow-serial-collector.png)

> 特别注意，Stop-The-World会挂起应用线程，造成应用的停顿。

#### 3.1.2 ParNew收集器

ParNew收集器，可以说是多线程的Serial收集器，在单线程中效率没有Serial高，但是在多线程中效率更高，且能与CMS收集器配合。

![ParNew收集器图解](http://7xtamf.com1.z0.glb.clouddn.com/image%2Fblog%2Fjava-gc-introduction%2Fshow-parnew-collector.png)

#### 3.1.3 Parallel Scavenge收集器

Parallel Scavenge收集器同样作用于新生代，并且也是采用多线程和复制算法来进行垃圾回收。Parallel Scavenge收集器关注的是**吞吐量**，即使得应用能够充分使用CPU。它与ParNew收集器一样，在回收过程会挂起所有的用户线程，造成应用停顿。

> 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。如果虚拟机运行了100分钟，其中垃圾收集花了1分钟，那么吞吐量就是99%。

### 3.2 老年代收集器

#### 3.2.1 Serial Old收集器

Serial Old收集器作用于老年代，采用单线程和**标记-整理算法**来实现垃圾回收。在回收垃圾的时候同样会挂起所有用户线程，造成应用的停顿。一般来说，老年代的容量都比新生代要大。

> Serial Old收集器还有一个重要的用途是作为CMS收集器的后备方案，在并发收集发生Concurrent Mode Failure的时候使用，进行内存碎片的整理。

#### 3.2.2 Parallel Old收集器

Parallel Old收集器是Parallel Scavenge收集器的老年代版本，采用**多线程和标记-整理**算法来实现老年代的垃圾回收。这个收集器主要是为了配合Parallel Scavenge收集器的使用，即当新生代选择了Parallel Scavenge收集器的情况下，老年代可以选择Parallel Old收集器。

> 在JDK1.6以前并没有提供Parallel Scavenge收集器，所以在1.6版本以前，Parallel Scavenge收集器只能与Serial Old收集器搭配使用。

#### 3.2.3 CMS收集器

CMS(Concurrent Mark Sweep)收集器是一款真正实现了并发收集的老年代收集器。CMS收集器以获取**最短回收停顿时间**为目标，采用**多线程并发以及标记-清除算法**来实现垃圾回收。CMS收集器可以最大程度地减少因垃圾回收而造成应用停顿的时间。

![CMS收集器图解](http://7xtamf.com1.z0.glb.clouddn.com/image%2Fblog%2Fjava-gc-introduction%2Fshow-cms-collector.png)

CMS垃圾收集分为以下几个阶段：

(1). 初始标记，标记GCRoots能直接关联到的对象，时间很短。

(2). 并发标记，进行GCRoots Tracing（可达性分析）过程，时间很长。

(3). 重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。

(4). 并发清除，回收内存空间，时间很长。

其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行。

说明：1. 对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降。2. 无法处理浮动垃圾，因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾，同时，由于用户线程并发执行，所以需要预留一部分老年代空间提供并发收集时程序运行使用。3. 由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。

虚拟机提供了-XX:+UseCMSCompactAtFullCollection参数来进行碎片的合并整理过程，这样会使得停顿时间变长，

虚拟机还提供了一个参数配置，-XX:+CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，接着来一次带压缩的GC。

> 1. 通常我们把发生在新生代的垃圾回收称为Minor GC，而把发生在老年代的垃圾回收称为Major GC，而FullGC是指整个堆内存的垃圾回收，包括对新生代、老年代和持久代的回收。一般情况下应用程序发生Minor GC的次数要远远大于Major GC和Full GC的次数。 
> 2. 在讲解GC的时候会涉及到**并行**和**并发**两个概念。在这里，并行指的是多个GC收集线程之间并行进行垃圾回收。而并发指的是多个GC收集线程与所有的用户线程能够交替执行

####3.3G1:最前沿的成果，用于取代CMS，本文不做介绍



##4.死亡对象相关

## 4.1死亡对象判定

#### 引用计数法Reference Counting Collector

对于堆中的每个对象实例都有一个引用计数器，初始化计数器为1，当任何其他变量赋值为这个对象的应用时，计数加1，当对象超过生命周期或者设置为新值时，对象实例的引用计数器减1。

任何**引用计数器为0的对象实例可以当做垃圾收集**。

但是若两个对象循环引用时，引用计数器无法处理。

####根搜索算法-----**可达性分析法**

这个算法的基本思想是通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。

在Java语言中，可以作为GCRoots的对象包括下面几种：

(1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。

(2). 方法区中的类静态属性引用的对象。

(3). 方法区中常量引用的对象。

(4). 本地方法栈中JNI(Native方法)引用的对象。

![可达性分析法](../img/可达性分析法.png)

#### 4.2四种引用状态

**1、强引用**

代码中普遍存在的类似"Object obj = new Object()"这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

**2、软引用**

描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java中的类SoftReference表示软引用。

**3、弱引用**

描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java中的类WeakReference表示弱引用。

**4、虚引用**

这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。Java中的类PhantomReference表示虚引用。

![](../img/四种引用.png)



## 5. JVM参数使用

### 5.1 堆内存相关

- **-Xms 与 -Xmx**

`-Xms`用于指定Java应用使用的最小堆内存，如`-Xms1024m`表示将Java应用最小堆设置为1024M。`-Xmx`用于指定Java应用使用的最大堆内存，如`-Xmx1024m`表示将Java应用最大堆设置为1024m。过小的堆内存可能会造成程序抛出OOM异常，所以正常发布的应用应该明确指定这两个参数。并且，一般会选择将`-Xms`与`-Xmx`设置成一样大小，防止JVM动态调整堆内存容量对程序造成性能影响。

- **-Xmn**

通过`-Xmn`可以设置堆内存中新生代的容量，以此达到间接控制老年代容量的作用，因为没有JVM参数可以直接控制老年代的容量。如`-Xmn256m`表示将新生代容量设置为256M。假如这个时候额外指定了`-Xms1024m -Xmx1024m`，那么老年代的容量为768M(1024-256=768)。

- **-XX:PermSize 与 -XX:MaxPermSize**

`-XX:PermSize`和`-XX:MaxPermSize`分别用于设置永久代的容量和最大容量。如`-XX:PermSize=64m -XX:MaxPermSize=128m`表示将永久代的初始容量设置为64M，最大容量设置为128M。

- **-XX:SurvivorRatio**

这个参数用于设置新生代中Eden区和Survivor(S0、S1)的容量比值。默认设置为`-XX:SurvivorRatio=8`表示Eden区与Survivor的容量比例为8:1:1。假设`-Xmn256m -XX：Survivor=8`，那么Eden区容量为204.8M(256M / 10 * 8)，S0和S1区的容量大小均为25.6M(256M / 10 * 1)。

### 5.2 GC收集器相关

- **-XX:+UseSerialGC**

虚拟机运行在client模式下的默认值，使用这个参数表示虚拟机将使用Serial + Serial Old收集器组合进行垃圾回收。

> -XX:+UseSerialGC表示使用这个设置，而-XX:-UseSerialGC表示禁用这个设置。

- **-XX:+UseParNewGC**

使用这个设置以后，虚拟机将使用ParNew + Serial Old收集器组合进行垃圾回收。

- **-XX:+UseConcMarkSweepGC**

使用这个设置以后，虚拟机将使用ParNew + CMS + Serial Old的收集器组合进行垃圾回收。注意Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器来进行回收(将会整理内存碎片)。

- **-XX:+UseParallelGC**

虚拟机运行在server模式下的默认值。使用这个设置，虚拟机将使用Parallel Scavenge + Serial Old(PS MarkSweep)的收集器组合进行垃圾回收。

- **-XX:+UseParallelOldGC**

使用这个设置以后，虚拟机将使用Parallel Scavengen + Parallel Old的收集器组合进行垃圾回收。

- **-XX:PretenureSizeThreshold**

设置直接晋升到老年代的对象大小，大于这个参数的对象将直接在老年代分配，而不是在新生代分配。注意这个值只能设置为字节，如`-XX:PretenureSizeThreshold=3145728`表示超过3M的对象将直接在老年代分配。

- **-XX:MaxTenuringThreshold**

设置晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄就会加1，当超过这个值时就进入老年代。默认设置为`-XX:MaxTenuringThreshold=15`。

- **-XX:ParellelGCThreads**

设置并行GC时进行内存回收的线程数。只有当采用的垃圾回收器是采用多线程模式，包括ParNew、Parallel Scavenge、Parallel Old、CMS，这个参数的设置才会有效。

- **-XX:CMSInitiatingOccupancyFraction**

设置CMS收集器在老年代空间被使用多少(百分比)后触发垃圾收集。默认设置`-XX:CMSInitiatingOccupancyFraction=68`表示老年代空间使用比例达到68%时触发CMS垃圾收集。仅当老年代收集器设置为CMS时候这个参数才有效。

- **-XX:+UseCMSCompactAtFullCollection**

设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅当老年代收集器设置为CMS时候这个参数才有效。

- **-XX:CMSFullGCsBeforeCompaction**

设置CMS收集器在进行多少次垃圾收集后再进行一次内存碎片整理。如设置`-XX:CMSFullGCsBeforeCompaction=2`表示CMS收集器进行了2次垃圾收集之后，进行一次内存碎片整理。仅当老年代收集器设置为CMS时候这个参数才有效。

### 5.3 GC日志相关

- **-XX:+PrintGCDetails**

表示输出GC的详细情况。

- **-XX:+PrintGCDateStamps**

指定输出GC时的时间格式，比指定`-XX:+PrintGCTimeStamps`可读性更高。

- **-Xloggc**

指定gc日志的存放位置。如`-Xloggc:/var/log/myapp-gc.log`表示将gc日志保存在磁盘`/var/log/`目录，文件名为`myapp-gc.log`。

## 6.总结

**Minor GC**:当Eden区满时，触发Minor GC,通过复制算法迅速清理死亡对象，若S1区域满，则将对象存放到持久区。

**Major GC\Full GC**:

（1）调用System.gc时，系统建议执行Full GC，但是不必然执行

（2）老年代空间不足

（3）持久区空间不足

（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存**（上升对象过多，而老年代并没有足够空间）**

（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小**（上升对象过大，而老年代并没有对应空间）**

**OOM的触发条件**：

* Full GC时，如果老年区空间不足，则会报OOM异常。
* gc与非gc时间耗时超过了GCTimeRatio的限制引发OOM

**降低GC的调优的策略：** 

* 通过NewRatio控制新生代老年代比例
* 通过MaxTenuringThreshold控制进入老年前生存次数等

