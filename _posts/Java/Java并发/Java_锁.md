---
title: Java_锁
date: 2018-04-11 09:49:59
tags: [Java]
---

## Java锁分类

* 公平锁/非公平锁
* 乐观锁/悲观锁
* 排它锁/共享锁
* 互斥锁/读写锁
* 可重入锁
* 偏向锁/轻量级锁/重量级锁



<!--more-->

## 公平锁/非公平锁

**公平锁**：多个线程等待锁时，按申请锁的先后顺序来获取锁。不会导致饥饿，但整体效率较低。

**非公平锁**：吞吐量大，但可能导致饥饿现象。

对于Java `ReentrantLock`而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。
对于`Synchronized`而言，也是一种非公平锁。由于其并不像`ReentrantLock`是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。

## 乐观锁/悲观锁

**悲观锁**：假定会发生并发冲突，通过枷锁来屏蔽一切可能违反数据完整性的操作。
**乐观锁**：假定不会发生并发冲突，只在提交操作时检测是否违反数据完整性。

因此在读操作密集的操作里，使用乐观锁会获得大量的性能提升。常常采用CAS算法，典型的例子是原子类，通过CAS自旋实现原子操作的更新。

而在写操作密集时，需要使用悲观锁来保证数据的安全。

## 独享（排他）锁/共享锁

**独享锁**：事务对数据加上排他锁，其他事务不能再对其添加任意锁，事务获取了数据**读写修改**权。

**共享锁**：事务对数据加上共享锁，其他事务只能继续对其添加共享锁，所有共享锁的数据**只能读取**。

## 互斥锁/读写锁

**互斥锁**:只允许**一个线程**持有的锁

**读写锁**：一个允许被**多个读进程或一个写进程**持有的锁`ReadWriteLock`

## 可重入锁

可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。

在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁。可重入锁最大的作用是避免死锁。

~~~java
synchronized void setA() throws Exception{
    Thread.sleep(1000);
    setB();
}

synchronized void setB() throws Exception{
    Thread.sleep(1000);
}
~~~

若非可重入锁，setB可能不会被当前线程执行，可能造成死锁。

## 分段锁

​	**分段锁**是一种锁的设计，对于`ConcurrentHashMap`而言，其实现并发的原理就是分段锁。每一个分段（Segment）都是类似于HashMap的结构，即内部拥有一个Entry数组，数组每个元素都是链表。同时每段都加上了ReentrantLock。

​	需要放入元素是，通过HashCode来判断所属的分段，然后对该分段加锁。

​	在统计Size时，需要获取全部的分段锁才能统计。

## 偏向锁/轻量级锁/重量级锁

这三种锁是指锁的状态，并且是针对`Synchronized`。Java 5通过引入锁升级的机制来实现高效`Synchronized`。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。

**偏向锁**是指一段同步代码一直被一个线程所访问，那么该线程会**自动获取锁**。降低获取锁的代价。
**轻量级锁**是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过**自旋**的形式尝试获取锁，**不会阻塞，提高性能**。
**重量级锁**是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

## 自旋锁

在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。