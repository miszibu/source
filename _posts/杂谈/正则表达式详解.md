---
title: 正则表达式详解
date: 2018-09-11 11:36:33
tags: [正则]
---

> 本文主要记录正则表达式的一些具体的应用，因为实在太容易遗忘，而且在工作上的作用很大。

<!--more-->

### 正则元字符

| 代码          | 功能                                                        | 案例                                                         |
| ------------- | ----------------------------------------------------------- | ------------------------------------------------------------ |
| .             | 匹配**除了换行符**以外的任何字符                            | .{3} 匹配3个对应字符 .*匹配任意个对应字符                    |
| \w            | 匹配**字母数字下划线**                                      | 等同于字符类[a-z0-9A-Z]                                      |
| \s            | 匹配任意的空白符包括空格，制表符(Tab)，换行符，中文全角空格 |                                                              |
| \d            | 匹配**数字**                                                | 等同于字符类[0-9]                                            |
| \b            | 匹配单词的开始或结束                                        | \bhello.*\bworld 匹配hello wolrd两个单词前有空格，中间有任意个字符的hello world |
| ^             | 匹配字符串的开始                                            | ^\d{5,12}$ 匹配一个只有5到12位数字的字符串                   |
| $             | 匹配字符串的结束                                            |                                                              |
| [u4e00-u9fa5] | 汉字匹配                                                    |                                                              |

---

### 字符转义 \

当需要查找**元字符**时，元字符前需要加**转义字符**，表示该元字符取其本来字符意思。
比如 \ .     \ \   \ * 等等。
C:\\ \windows 匹配 C:\windows



------

### 重复-限定符

| 语法  | 说明             | 案例                              |
| ----- | ---------------- | --------------------------------- |
| *     | 匹配零次或更多次 |                                   |
| +     | 匹配一次或更多次 | ^\w+ 匹配字符串或一行的第一个单词 |
| ？    | 匹配零次或一次   |                                   |
| {n}   | 重复n次          |                                   |
| {n,m} | 重复n次到m次     |                                   |
| {n,}  | 重复n次到更多次  |                                   |

---

### 字符类:[]

通过中括号[]限定选择的字符

[aeiou]匹配元音字符，[.?!]匹配三个字符，[0-9a-zA-Z]等同于\w，[0-9]等同于\d



---

### 分支条件：|

当需要正则匹配多个条件时，使用|分割多个正则表达式，当匹配到其中任意一个条件时，即匹配成功，需要注意他是**从左到右匹配**的。

>(0\d{2}-\d{8})|(\d{3}-\d{7})



---

### 分组 ：（）

单个字符可以直接加限定符，多个字符想多次校验可以使用（）

> (\d{1,3}.){3}\d{1,3}

IP地址校验，然而存在着888.888.888.888等错误数据，因为这是SQL的一个弊端，不支持算数校验。所以为了解决IP地址校验的问题，sql就会写的比较冗长。

>(2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。

这样就可以校验正确格式的IP地址了



---



### 反义：^ 和大写

| 代码/语法 | 说明                                       |
| --------- | ------------------------------------------ |
| \W        | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \S        | 匹配任意不是空白符的字符                   |
| \D        | 匹配任意非数字的字符                       |
| \B        | 匹配不是单词开头或结束的位置               |
| [^x]      | 匹配除了x以外的任意字符                    |
| [^aeiou]  | 匹配除了aeiou这几个字母以外的任意字符      |



---

### 贪婪与懒惰：*？+？

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。

有时，我们更需要懒惰匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：

a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。

为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。

| 代码/语法 | 说明                            |
| --------- | ------------------------------- |
| *?        | 重复任意次，但尽可能少重复      |
| +?        | 重复1次或更多次，但尽可能少重复 |
| ??        | 重复0次或1次，但尽可能少重复    |
| {n,m}?    | 重复n到m次，但尽可能少重复      |
| {n,}?     | 重复n次以上，但尽可能少重复     |



---

### 相关资料

[正则表达式300钟入门教程](http://deerchao.net/tutorials/regex/regex.htm) （网页）

[精通正则表达式 (豆瓣)](https://link.zhihu.com/?target=http%3A//book.douban.com/subject/2154713/) （动物书）

由入门教程入门，了解正则相关基础知识，达到能够编写日常正则校验的水平后，若仍然需要则看书，深入学习。
